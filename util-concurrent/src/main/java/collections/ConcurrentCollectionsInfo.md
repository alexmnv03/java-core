# Concurrent Collections

Обычные наборы данных, реализующих интерфейсы List, Set и Map, нельзя использовать 
в многопоточных приложениях, если требуется синхронизация, т.е. такие коллекции недопустимы 
для одновременного чтения и изменения данных разными потоками. 
Методы обрамления Collections framework (synchronizedList, synchronizedSet, synchronizedMap), 
появившиеся в JDK 1.2, имеют существенный недостаток, связанный с препятствованием 
масштабируемости, поскольку с коллекцией одновременно может работать только один поток.

Пакет java.util.concurrent предлагает свой набор потокобезопасных классов, 
допускающих разными потоками одновременное чтение и внесение изменений. 
Итераторы классов данного пакета представляют данные на определенный момент времени и 
не вызывают исключение ConcurrentModificationException. 
Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии 
внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не
будет ConcurrentModificationException. 
Следует помнить, что при копировании массива копируются только ссылки на объекты.

CopyOnWriteArrayList реализует алгоритм CopyOnWrite и является потокобезопасным аналогом ArrayList. 

CopyOnWriteArraySet выполнен на основе CopyOnWriteArrayList с реализацией интерфейса Set.

ConcurrentHashMap<K, V> реализует (implements) интерфейс java.util.concurrent. ConcurrentMap и 
отличается от HashMap и Hashtable внутренней структурой хранения пар key-value. 
СoncurrentHashMap использует несколько сегментов, и данный класс можно рассматривать как 
группу HashMap’ов. По умолчанию количество сегментов равно 16. Доступ к данным определяется 
по сегментам, а не по объекту. Если пара key-value хранится в 10-ом сегменте, то 
ConcurrentHashMap заблокирует, при необходимости, только 10-й сегмент, и не будет блокировать 
остальные 15. Итераторы данного класса фиксируют структуру данных на момент 
начала его использования. Описание ConcurrentHashMap<K, V> с примером представлено здесь.



ConcurrentNavigableMap расширяет возможности интерфейса NavigableMap для использования 
в многопоточных приложениях; итераторы класса декларируются как потокобезопасные и не 
вызывают ConcurrentModificationException.

ConcurrentSkipListMap является аналогом коллекции TreeMap с сортировкой данных по ключу 
и с поддержкой многопоточности.

ConcurrentSkipListSet выполнен на основе ConcurrentSkipListMap с реализацией интерфейса Set.
