# Очередь ConcurrentLinkedQueue
Класс ConcurrentLinkedQueue формирует неблокирующую, основанную на связанных узлах и  
ориентированную на многопоточное исполнение очередь. Размер очереди ConcurrentLinkedQueue не  
имеет ограничений. Эта очередь реализует принцип FIFO — «первым прибыл, первым убыл». Новые  
элементы размещаются в хвосте очереди, а операции извлечения получают элементы из головы очереди.
Этот класс не разрешает использование null элементов.

Очередь ConcurrentLinkedQueue использует эффективный неблокирующий алгоритм "без ожидания"  
предложенный Мэджедом М. Майклом и Майклом Л. Скоттом (Maged M. Michael, Michael L. Scott).

Итераторы класса отражают состояние очереди на определенный момент времени его создания и не  
вызывают ConcurrentModificationException. Содержавшиеся в очереди элементы с начала создания  
iterator'a, будут возвращены точно по запросу.

Аккуратно используйте метод size, который в отличие от большиства наборов, не является  
constant-time operation. Из-за асинхронной природы этой очереди, определение текущего количества 
элементов может быть не точным и требует обхода элементов, если этот набор изменяется во время  
обхода. Объемные операции addAll, removeAll, retainAll, containsAll, equals и toArray не  
гарантируют, что будут выполнены атомарно. Например, iterator, работающий с методом addAll, мог 
бы просмотреть только некоторые из добавленных элементов.

Очередь ConcurrentLinkedQueue и iterator реализуют все дополнительные методы интерфейсов 
Queue и Iterator.
