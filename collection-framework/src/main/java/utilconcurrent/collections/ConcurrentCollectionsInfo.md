# Concurrent Collections

Обычные наборы данных, реализующих интерфейсы List, Set и Map, нельзя использовать 
в многопоточных приложениях, если требуется синхронизация, т.е. такие коллекции недопустимы 
для одновременного чтения и изменения данных разными потоками. 
Методы обрамления Collections framework (synchronizedList, synchronizedSet, synchronizedMap), 
появившиеся в JDK 1.2, имеют существенный недостаток, связанный с препятствованием 
масштабируемости, поскольку с коллекцией одновременно может работать только один поток.

Пакет java.util.concurrent предлагает свой набор потокобезопасных классов, 
допускающих разными потоками одновременное чтение и внесение изменений. 
Итераторы классов данного пакета представляют данные на определенный момент времени и 
не вызывают исключение ConcurrentModificationException. 
Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии 
внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не
будет ConcurrentModificationException. 
Следует помнить, что при копировании массива копируются только ссылки на объекты.

CopyOnWriteArrayList реализует алгоритм CopyOnWrite и является потокобезопасным аналогом ArrayList. 

Класс CopyOnWriteArrayList содержит изменяемую ссылку на неизменяемый массив, 
обеспечивая преимущества потокобезопасности без необходимости использования блокировок. 
Т.е. при выполнении модифицирующей операции CopyOnWriteArrayList создаёт новую копию списка 
и гарантирует, что её итераторы вернут состояние списка на момент создания итератора и не
вызовут ConcurrentModificationException. Описание CopyOnWriteArrayList с примером представлено здесь.

ConcurrentHashMap<K, V> реализует (implements) интерфейс java.util.concurrent.ConcurrentMap и отличается от HashMap и Hashtable внутренней структурой хранения пар key-value. СoncurrentHashMap использует несколько сегментов, и данный класс можно рассматривать как группу HashMap’ов. По умолчанию количество сегментов равно 16. Доступ к данным определяется по сегментам, а не по объекту. Итераторы данного класса фиксируют структуру данных на момент начала его использования. Описание ConcurrentHashMap<K, V> с примером представлено здесь.

CopyOnWriteArraySet выполнен на основе CopyOnWriteArrayList с реализацией интерфейса Set. Описание CopyOnWriteArraySet с примером представлено здесь.

ConcurrentNavigableMap расширяет возможности интерфейса NavigableMap для использования в многопоточных приложениях; итераторы класса декларируются как потокобезопасные и не вызывают ConcurrentModificationException.

ConcurrentSkipListMap является аналогом коллекции TreeMap с сортировкой данных по ключу и с поддержкой многопоточности.

ConcurrentSkipListSet выполнен на основе ConcurrentSkipListMap с реализацией интерфейса Set.
